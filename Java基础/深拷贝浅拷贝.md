深拷贝和浅拷贝
===

对象拷贝有哪些
---

对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个有着相同类类型的对象中去。在程序中拷贝对象是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。

Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)

浅拷贝
---

浅拷贝是指将一个对象中的基本类型的成员变量的值复制一份给另一个对象，而将引用类型的成员变量指向原来的对象所指向的内存地址。也就是说，浅拷贝只是将对象中的基本类型的成员变量的值复制一份给另一个对象，而将引用类型的成员变量指向原来的对象所指向的内存地址。

浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象

在这个例子中，让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()方法。从输出结果中我们可以看到，对原始对象stud的"name"属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象subj的"name"属性所做的改变影响到了拷贝对象clonedStud。

理解深拷贝
---

深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。

```  java
   @Override
 public Object clone() { 
      // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立
      Student s = new Student(name, subj.getName()); 
      return s; 
   } 
```

很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。

序列化进行拷贝
---

序列化属于深拷贝
可能你会问，序列化是属于那种类型拷贝？答案是：通过序列化来实现深拷贝。可以思考一下，为何序列化对象要用深拷贝而不是用浅拷贝呢？

可以序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的

确保对象图中的所有类都是可序列化的
创建输入输出流
使用这个输入输出流来创建对象输入和对象输出流
将你想要拷贝的对象传递给对象输出流
从对象输入流中读取新的对象并且转换回你所发送的对象的

```  java
   public static Object deepCopy(Object object) { 
      try { 
         // 将对象写到流里 
         ByteArrayOutputStream bo = new ByteArrayOutputStream(); 
         ObjectOutputStream oo = new ObjectOutputStream(bo); 
         oo.writeObject(object); 
         // 从流里读出来 
         ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); 
         ObjectInputStream oi = new ObjectInputStream(bi); 
         return (oi.readObject()); 
      } catch (Exception e) { 
         System.out.println("Exception in ObjectCloner = " + e); 
         return null; 
      } 
   } 
```

注意，序列化这种方式有其自身的限制和问题：因为无法序列化transient变量, 使用这种方法将无法拷贝transient变量。再就是性能问题。创建一个socket, 序列化一个对象, 通过socket传输它, 然后反序列化它，这个过程与调用已有对象的方法相比是很慢的。所以在性能上会有天壤之别。如果性能对你的代码来说是至关重要的，建议不要使用这种方式。它比通过实现Clonable接口这种方式来进行深拷贝几乎多花100倍的时间。

延迟拷贝
---

延迟拷贝是浅拷贝和深拷贝的一个组合，它是一种优化的拷贝策略。
当最开始拷贝一个对象时，会使用**速度较快的浅拷贝**，还会使用一个计数器来记录有多少对象共享这个数据。当程序想要修改原始的对象时，它会决定数据是否被共享（通过检查计数器）并根据需要进行深拷贝。
延迟拷贝从外面看起来就是深拷贝，但是只要有可能它就会利用浅拷贝的速度。当原始对象中的引用**不经常改变**的时候可以使用延迟拷贝。由于存在计数器，效率下降很高，但只是常量级的开销。而且, 在某些情况下, 循环引用会导致一些问题。

如何选择拷贝方式
---

* 如果对象的属性全是基本类型的，那么可以使用浅拷贝。
* 如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。
* 意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。没有一成不变的规则，一切都取决于具体需求。

数组除了默认实现了clone()方法之外，还提供了Arrays.copyOf方法用于拷贝，这两者都是浅拷贝。

```  java
    int[] a = {1, 2, 3}; 
    int[] b = a.clone(); 
    int[] c = Arrays.copyOf(a, a.length); 
```

集合的拷贝
---

集合的拷贝也是浅拷贝，如果集合中的元素是引用类型，那么拷贝后的集合中的元素和原集合中的元素是同一个对象。

```  java
    List<String> list = new ArrayList<>(); 
    list.add("a"); 
    list.add("b"); 
    list.add("c"); 
    List<String> list2 = new ArrayList<>(list); 
    list2.add("d"); 
    System.out.println(list); // [a, b, c] 
    System.out.println(list2); // [a, b, c, d] 
```

集合深拷贝
----

在某些特殊情况下，如果需要实现集合的深拷贝，那就要创建一个新的集合，然后通过深拷贝原先集合中的每个元素，将这些元素加入到新的集合当中。

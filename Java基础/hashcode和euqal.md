介绍
===

首先我们需要知道hashCode方法和equals方法都是属于Object类的方法。既然属于Object中public修饰的方法，那言外之就是所有对象默认都有这两个方法，只是有时候有的对象已对这两个方法进行了重写。

不会创建“类对应的散列表
---

里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。

在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用。

会创建“类对应的散列表
---

这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。

在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：

    如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。

    如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。

此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。

举例，创建Person类的HashSet集合，必须同时覆盖Person类的equals() 和 hashCode()方法。

总结
---

1.同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。
如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。

2.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象。不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实。

3.一旦重写了equals()函数（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()函数。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段。

如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题

如果单单只是覆盖equals()方法。我们会发现，equals()方法没有达到我们想要的效果。
hashCode方法是返回一个对象的hash值（int类型），利用对象地址生成一个int类型的数。

equals方法是比较两个对象是否为同一个对象。
关于hashCode方法如何重写，只要满足，两个对象equals相等时，hashCode相等就行。

看看大佬们是如何写的。

HashMap是先使用key的hash值去查找对应的table下表，再通过key的hashCode进行比较，相等的话再比较equals是不是相等。
上面hashCode为什么这么写呢？
1.把某个非零的常数值,比如说0(一个你喜欢的数字),保存在一个名为result的int类型的变量中.
2.对于对象中每个关键域(指equals方法中涉及的每个域),完成以下步骤:
a.为该域计算int类型的散列码c:
i.如果该域是boolean类型,则计算(f?1:0)
ii.如果该域是byte,char,short或者int类型,则计算(int)f.
iii.如果该域是long类型,则计算(int)(f^(f>>>32)).
iv.如果该域是float类型,则计算Float.floatToIntBits(f).
v.如果该域是double类型,则计算Double.doubleToLongBits(f),然后按照步骤2.a.iii,为得到的long类型值计算散列值.
vi.如果该域是一个对象引用,并且该类的equals方法通过递归地调用equals的方式来比较这个域,则同样为这个域递归地调用hashCode.如果需要更加复杂的比较,则为这个域计算一个"范式",然后针对这个范式调用hashCode.如果这个域的值为null,则返回0(或者其他某个常数,但通常是0).
vii.如果该域是一个数组,则要把每一个元素当做单独的域来处理.也就是说,递归地应用上述规则,对每个重要的元素计算一个散列码,然后根据步骤2.b中的做法把这些散列值组合起来.如果数组域中的每个元素都很重要,可以利用发行版本1.5中增加的其中一个Arrays.hashCode方法.
b.按照下面的公式,把步骤2.a中计算得到的散列码c合并到result中:
result = 31 * result +c;
3.返回result

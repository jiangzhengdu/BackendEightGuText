线程和进程的区别
====

死锁的四个条件
---

互斥条件（Mutual exclusion） · 请求与保持条件（Hold and wait） · 不可剥夺条件（No pre-emption） · 环路/循环等待条件（Circular ...
1） 互斥条件：一个资源每次只能被一个进程使用。
2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

进程和线程定义
---

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

进程和线程关系
---

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

进程和线程区别
---

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

* 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
* 线程的划分尺度小于进程，使得多线程程序的并发性高。
* 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
* 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
* 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
* 优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

线程的状态
---

    一、新建状态(NEW) 创建后尚未启动
    二、可运行(RUNNABLE)其他状态->就绪 可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 Running 和 Ready。
    三、阻塞状态(BLOCKED) 等待获取一个排它锁，如果其线程释放了锁就会结束此状态。
    四、无限期等待(Waiting)
    等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。
    进入的办法：调用 Object.wait() 方法，或者调用 Thread.join() 方法，或者调用 LockSupport.park() 方法。
    退出的办法：调用 Object.notify() 方法，或者调用 Object.notifyAll() 方法，或者调用 Thread.interrupt() 方法，或者调用 LockSupport.unpark() 方法。
    运行->等待 等待->就绪
    五、限期等待(Timed Waiting) 运行->超时等待 超时等待->就绪
    无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
    调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。时间结束就会退出睡眠状态。
    调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。时间结束 / Object.notify() / Object.notifyAll()
    设置了 Timeout 参数的 Thread.join() 方法 退出方法：时间结束 / 被调用的线程执行完毕
    睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入等待状态。
    六、消亡状态TERMINATED 可以是线程结束任务之后自己结束，或者产生了异常而结束。

线程基本方法
---

线程相关的基本方法有 wait， notify， notifyAll， sleep， join， yield 等。

线程等待(wait)
---

调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的
是调用 wait()方法后， **会释放对象的锁**。因此， wait 方法一般用在同步方法或同步代码块中。

线程睡眠(sleep)
---

sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致 线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态

线程让步(yield)
---

yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下， 优先级高的线程有更大的可能性成功竞争得到 CPU 时间片， 但这又不是绝对的，有的操作系统对 线程优先级并不敏感。

线程中断(interrupt)
---

中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。 这
个线程本身并不会因此而改变状态(如阻塞，终止等)。

1. 调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线
程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。
2. 若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出
InterruptedException,从而使线程提前结束 TIMED-WATING 状态。
3. 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异
常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。
4. 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。

Join 等待其他线程终止
---

join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。
在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
为什么要用 join()方法?
很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要 在子线程结束后再结束，这时候就要用到 join() 方法 。
  System.out.println(Thread.currentThread().getName() + "线程运行开始!"); Thread6 thread1 = new Thread6();
thread1.setName("线程 B");
thread1.join();
System.out.println("这时 thread1 执行完毕之后才能执行主线程");

线程唤醒(notify)
---

Object 类中的 notify() 方法， 唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调 用其中一个 wait() 方法，在对象的监视器上等待， 直到当前的线程放弃此对象上的锁定，才能继 续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞 争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。

wait() notify() notifyAll()
---

调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。它们都属于 Object 的一部分，而不属于 Thread。只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。
如果是通过notifyAll唤起的线程,默认情况是最后进入的会先被唤起来,即**LIFO的策略**;
**notify()或者notifyAll()调用时并不会真正释放对象锁, 必须等到synchronized方法或者语法块执行完才真正释放锁.**
notify在源码的注释中说到notify选择唤醒的线程是任意的，但是依赖于具体实现的jvm.
我们都知道, JVM有很多实现, 比较流行的就是hotspot!
带着质疑, 我们不妨接下去看看jdk1.8, hotspot中对于notify()究竟是如何实现的
synchronized的wait和notify是位于ObjectMonitor.cpp中
notify过程调用的是DequeueWaiter方法：
这里实际上是将_WaitSet中的第一个元素进行出队操作,
这也说明了**notify是个顺序操作, 具有公平性**.

public void test()
{
    Object object = new Object();
    synchronized (object){
        object.notifyAll();
        while (true){
        }
    }
}

如上, 虽然调用了notifyAll, 但是紧接着进入了一个死循环。这会导致一直不能出临界区, 一直不能释放对象锁。
所以，即使它把所有在等待池中的线程都唤醒放到了对象的锁池中，
但是锁池中的所有线程都不会运行，因为他们始终拿不到锁

为何wait&notify必须要加synchronized锁?
---

从实现上来说，这个synchronized锁至关重要!
正因为这把锁，才能让整个wait/notify运转起来.
synchronized代码块通过javap生成的字节码中包含monitorenter 和 monitorexit 指令
执行monitorenter指令可以获取对象的monitor，
而lock.wait()方法通过调用native方法wait(0)实现，其中接口注释中有这么一句：
The current thread must own this object's monitor.
表示线程执行 lock.wait() 方法时，必须持有该lock对象的monitor.

为什么wait方法可能抛出InterruptedException异常?
---

这个异常大家应该都知道，当我们调用了某个线程的interrupt方法时，对应的线程会抛出这个异常;
wait方法也不希望破坏这种规则，
因此就算当前线程因为wait一直在阻塞，当某个线程希望它起来继续执行的时候，它还是得从阻塞态恢复过来;
而wait方法被唤醒起来的时候会去检测这个状态，当有线程interrupt了，它就会抛出这个异常从阻塞状态恢复过来。
这里有两点要注意：

    如果被interrupt的线程只是创建了，并没有start，那等他start之后进入wait态之后也是不能会恢复的；

    如果被interrupt的线程已经start了，在进入wait之前，如果有线程调用了其interrupt方法，那这个wait等于什么都没做，会直接跳出来，不会阻塞；

notifyAll是怎么实现全唤起所有线程?
----

或许大家立马就能想到一个for循环就搞定了，不过在JVM里没实现这么简单，而是借助了monitorexit.
上面提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块;
所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程;
然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推.
同样这这是一个策略的问题，JVM里提供了挨个直接唤醒线程的参数，不过很少使用, 这里就不提了。

wait的线程是否会影响性能?
----

这是个大家比较关心的话题.

wait/nofity 是通过JVM里的 park/unpark 机制来实现的，在Linux下这种机制又是通过pthread_cond_wait/pthread_cond_signal 来实现的;

因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。
但是这个线程会占用一定的内存，因为它会被放到一个等待队列里面，这个队列是在JVM里面的，所以这个内存是在JVM里面的，不会影响到操作系统的内存。

所有的方法
---

1. sleep():强迫一个线程睡眠N毫秒。
2. isAlive(): 判断一个线程是否存活。
3. join(): 等待线程终止。
4. activeCount(): 程序中活跃的线程数。
5. enumerate(): 枚举程序中的线程。
6. currentThread(): 得到当前线程。
7. isDaemon(): 一个线程是否为守护线程。
8. setDaemon(): 设置一个线程为守护线程。 (用户线程和守护线程的区别在于，是否等待主线
程依赖于主线程结束而结束)
9. setName(): 为线程设置一个名称。
10. wait(): 强迫一个线程等待。 11.notify(): 通知一个线程继续运行。
11. setPriority(): 设置一个线程的优先级。
12. getPriority()::获得一个线程的优先级。

进程
(有时候也称做任务)是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程(创建他们的进程)共享同一地址空间(一段内存区域)和其他资源的轻量级的进程。

上下文
是指某一时间点 CPU 寄存器和程序计数器的内容。

寄存器
是 CPU 内部的数量较少但是速度很快的内存(与之对应的是 CPU 外部相对较慢的 RAM 主内存)。寄存器通过对常用值(通常是运算的中间值)的快速访问来提高计算机程序运行的速度

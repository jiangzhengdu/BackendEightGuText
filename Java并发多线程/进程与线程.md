线程和进程的区别
====

死锁的四个条件：
互斥条件（Mutual exclusion） · 请求与保持条件（Hold and wait） · 不可剥夺条件（No pre-emption） · 环路/循环等待条件（Circular ...
1） 互斥条件：一个资源每次只能被一个进程使用。
2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

1.定义

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

2.关系

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。

3.区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1  简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2 线程的划分尺度小于进程，使得多线程程序的并发性高。

3 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4  线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

6 优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

线程的状态
---

    一、新建状态(NEW)
    二、运行状态(RUNNABLE) 就绪状态（READY) 其他状态->就绪 ...
    三、阻塞状态(BLOCKED)
    四、等待状态(WAITING) 运行->等待 等待->就绪
    五、超时等待状态(TIMED_WAITING) 运行->超时等待 超时等待->就绪
    六、消亡状态

线程基本方法
---

线程相关的基本方法有 wait， notify， notifyAll， sleep， join， yield 等。

线程等待(wait)
---

调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的
是调用 wait()方法后， 会释放对象的锁。因此， wait 方法一般用在同步方法或同步代码块中。 55、线程睡眠(sleep)

sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致 线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态

线程让步(yield)
---

yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下， 优先级高的线程有更大的可能性成功竞争得到 CPU 时间片， 但这又不是绝对的，有的操作系统对 线程优先级并不敏感。
57、线程中断(interrupt) 中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。 这
个线程本身并不会因此而改变状态(如阻塞，终止等)。

1. 调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线
程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。
2. 若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出
InterruptedException,从而使线程提前结束 TIMED-WATING 状态。
3. 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异
常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。
4. 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。
58、Join 等待其他线程终止
join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞
状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 59、为什么要用 join()方法?
很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要 在子线程结束后再结束，这时候就要用到 join() 方法 。
  System.out.println(Thread.currentThread().getName() + "线程运行开始!"); Thread6 thread1 = new Thread6();
thread1.setName("线程 B");
thread1.join();
System.out.println("这时 thread1 执行完毕之后才能执行主线程");

线程唤醒(notify)
---

Object 类中的 notify() 方法， 唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调 用其中一个 wait() 方法，在对象的监视器上等待， 直到当前的线程放弃此对象上的锁定，才能继 续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞 争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。

线程其他方法
---

1. sleep():强迫一个线程睡眠N毫秒。
2. isAlive(): 判断一个线程是否存活。
3. join(): 等待线程终止。
4. activeCount(): 程序中活跃的线程数。
5. enumerate(): 枚举程序中的线程。
6. currentThread(): 得到当前线程。
7. isDaemon(): 一个线程是否为守护线程。
8. setDaemon(): 设置一个线程为守护线程。 (用户线程和守护线程的区别在于，是否等待主线
程依赖于主线程结束而结束)
9. setName(): 为线程设置一个名称。
10. wait(): 强迫一个线程等待。 11.notify(): 通知一个线程继续运行。
11. setPriority(): 设置一个线程的优先级。
12. getPriority()::获得一个线程的优先级。

进程
(有时候也称做任务)是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程(创建他们的进程)共享同一地址空间(一段内存区域)和其他资源的轻量 级的进程。

上下文
是指某一时间点 CPU 寄存器和程序计数器的内容。

寄存器
是 CPU 内部的数量较少但是速度很快的内存(与之对应的是 CPU 外部相对较慢的 RAM 主内 存)。寄存器通过对常用值(通常是运算的中间值)的快速访问来提高计算机程序运行的速度。

幂等性
===

什么是幂等性
---

    幂等性定义:
        一次和多次请求某一个资源对于资源本身应该具有同样的结果
        任意多次执行对资源本身所产生的影响均与一次执行的影响相同

    幂等性定义的几个重点:

        幂等不仅仅只是一次或者多次请求对资源没有副作用
            比如,查询数据库操作,没有增删改,无论多少次操作对数据库都没有任何影响
        幂等还包括第一次请求的时候对资源产生了副作用,但是以后的多次请求都不会再对资源产生副作用
        幂等关注的是以后多次请求是否对资源产生副作用,并不关注结果
        网络超时等问题,不是幂等的讨论范围
    幂等性是系统服务对外一种承诺,而不是实现
    承诺只要调用接口成功,外部多次调用对系统的影响是一致的
    声明为幂等的服务会认为外部调用失败是常态,并且失败后必然会有重试

幂等性的重要性
---

任意多次执行所产生的影响均与一次执行的影响相同，这是幂等性的核心特点。其实在我们编程中主要操作就是CURD，其中读取（Retrieve）操作和删除（Delete）操作是天然幂等的，受影响的就是创建（Create）、更新（Update）。

对于业务中需要考虑幂等性的地方一般都是接口的重复请求，重复请求是指同一个请求因为某些原因被多次提交。导致这个情况会有**几种场景**：

    前端重复提交：提交订单，用户快速重复点击多次，造成后端生成多个内容重复的订单。
    接口超时重试：对于给第三方调用的接口，为了防止网络抖动或其他原因造成请求丢失，这样的接口一般都会设计成超时重试多次。
    消息重复消费：MQ消息中间件，消息重复消费。

对于一些业务场景影响比较大的，接口的幂等性是个必须要考虑的问题，例如金钱的交易方面的接口。否则一个错误的、考虑不周的接口可能会给公司带来巨额的金钱损失，那么背锅的肯定是程序员自己了。

幂等性实现方式
---

对于和web端交互的接口，我们可以在前端拦截一部分，例如防止表单重复提交，按钮置灰、隐藏、不可点击等方式。

但是前端做控制实际效益不是很高，懂点技术的都会模拟请求调用你的服务，所以安全的策略还是需要从后端的接口层来做。

那么后端要实现分布式接口的幂等性有哪些策略方式呢？主要可以从以下几个方面来考虑实现

保证幂等策略
---

    幂等需要通过唯一的业务单号来保证:
        相同的业务单号,认为是同一业务
        使用唯一的业务单号确保:后面多次相同业务单号的处理逻辑和执行效果是一致的

防重复提交策略

    在保证幂等的策略中,执行是分两步执行的,后面一步依赖上面一步的查询结果,这样就无法保证原子性

    无法保证原子性在高并发的情况下会存在问题:
        第二次请求在第一次请求的下一步订单状态没有修改为"已支付状态"时进行
        为了解决这个问题 :将查询和变更状态操作加锁,并将并行操作改为串行执行

Token机制
---

针对前端重复连续多次点击的情况，例如用户购物提交订单，提交订单的接口就可以通过 Token 的机制实现防止重复提交。

服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，服务器会把token保存到redis中。（微服务肯定是分布式了，如果单机就适用jvm缓存）。
然后调用业务接口请求时，把token携带过去，一般放在请求头部。
服务器判断token是否存在redis中，存在表示第一次请求，这时把redis中的token删除，继续执行业务。
如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。

这个操作是一个INSERT+UPDATE操作，本身属于一个POST请求，但是需要保证幂等性来满足上游系统，原本的幂等性设计是根据数据库中有没有记录来确定是否有过处理记录，而数据库的数据改变是事务提交之后的，这样的设计是完全无法保证高并发下的幂等的，而此次的入手点就是修复重复提交

数据库去重表
---

往去重表里插入数据的时候，利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。例如设计如下的数据库表

``` SQL

CREATE TABLE `t_idempotent` (
  `id` int(11) NOT NULL COMMENT 'ID',
  `serial_no` varchar(255)  NOT NULL COMMENT '唯一序列号',
  `source_type` varchar(255)  NOT NULL COMMENT '资源类型',
  `status` int(4) DEFAULT NULL COMMENT '状态',
  `remark` varchar(255)  NOT NULL COMMENT '备注',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `modify_by` bigint(20) DEFAULT NULL COMMENT '修改人',
  `modify_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
  UNIQUE KEY `key_s` (`serial_no`,`source_type`, `remark`)  COMMENT '保证业务唯一性'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='幂等性校验表';
```

我们注意看如下这几个关键性字段，

    serial_no：唯一序列号的值，在这里我设置的是通过注解@IdempotentKey来标识请求对象中的字段，通过对他们 MD5 加密获取对应的值。
    source_type：业务类型，区分不同的业务，订单，支付等。
    remark：是由标识字段的拼接成的字符串，拼接符为 “|”。

由于数据建立了 serial_no,source_type, remark 三个字段组合构成的唯一索引，所以可以通过这个来去重达到接口的幂等性，具体的代码设计如下，

问题
---

另外，使用数据库防重表的方式它有个严重的缺点，那就是系统容错性不高，如果幂等表所在的数据库连接异常或所在的服务器异常，则会导致整个系统幂等性校验出问题。如果做数据库备份来防止这种情况，又需要额外忙碌一通了啊。

幂等性redis分布式锁
---

Redis实现的方式就是将唯一序列号作为Key，唯一序列号的生成方式和上面介绍的防重表的一样，value可以是你想填的任何信息。唯一序列号也可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。当然这里需要设置一个 key 的过期时间，否则 Redis 中会存在过多的 key。

Redis做一个分布式锁，将执行操作和分布式锁结合，修改后的Server端步骤如下

根据订单号作为幂等性的标识

使用Redis的SetNX把订单号放在Redis里，设置一个中等的过期时间1分钟，如果没有拿到分布式锁则进行自旋

每次请求第一步操作是根据订单号进行查询，发现有数据则将原结果返回

进行业务处理，处理此交易的所有流水和余额

提交事务

释放Redis锁

Redis的SetNx方法并不能同时设置超时时间，所以原方案其实是两步操作，没有保证原子性（自己发现）

分布式锁的时间和数据库事务的等待时间不一致，分布式锁的1分钟等待时间远远低于设置的数据库事务等待时间，所以在超过1分钟的时候仍有可能绕过幂等性校验

如果想要解决第一个问题，有2种可行方案：

    开启Redis事务
    在Redis锁中添加过期时间

将事务等待时间和分布式锁生效时间全部设置N，在这个时间内只有一个线程会争夺到锁并处理，如果失败就会发起重试，线程处理+M次重试的总时间和也为N

状态机
---

对于很多业务是有一个业务流转状态的，每个状态都有前置状态和后置状态，以及最后的结束状态。例如流程的待审批，审批中，驳回，重新发起，审批通过，审批拒绝。订单的待提交，待支付，已支付，取消。

以订单为例，已支付的状态的前置状态只能是待支付，而取消状态的前置状态只能是待支付，通过这种状态机的流转我们就可以控制请求的幂等。

假设当前状态是已支付，这时候如果支付接口又接收到了支付请求，则会抛异常或拒绝此次处理。

总结
---

通过以上的了解我们可以知道，针对不同的业务场景我们需要灵活的选择幂等性的实现方式。

例如防止类似于前端重复提交、重复下单的场景就可以通过 Token 的机制实现，而那些有状态前置和后置转换的场景则可以通过状态机的方式实现幂等性，对于那些重复消费和接口重试的场景则使用数据库唯一索引的方式实现更合理。

进程线程协程
===

一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源， 但是每个线程有自己的程序计数器、虚拟机栈和本地方法栈。

线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和 进程最大的不同在于基本上 进程是独立的，而线程则不一定，因为同一进程中的线程有可能会相互响。线程执行开销小，但不利于资源的管理和保护;而进程正相反

子进程和线程的区别
---

子进程有自己的资源，比线程独立于父进程，可以在父进程退出后执行，如LINUX的守护护进程 就是这样的，线程使用的是父进程的资源，在父进程退出后跟着退出

协程
---

协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多

但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

Python对协程的支持是通过generator实现的。

在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。

但是Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。

```python
def consumer():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[CONSUMER] Consuming %s...' % n)
        r = '200 OK'

def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print('[PRODUCER] Producing %s...' % n)
        r = c.send(n)
        print('[PRODUCER] Consumer return: %s' % r)
    c.close()

c = consumer()
produce(c)
```

注意到consumer函数是一个generator，把一个consumer传入produce后：
    首先调用c.send(None)启动生成器；
    然后，一旦生产了东西，通过c.send(n)切换到consumer执行；
    consumer通过yield拿到消息，处理，又通过yield把结果传回；
    produce拿到consumer处理的结果，继续生产下一条消息；
    produce决定不生产了，通过c.close()关闭consumer，整个过程结束。

整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。

最后套用Donald Knuth的一句话总结协程的特点：子程序就是协程的一种特例

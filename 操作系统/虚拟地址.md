虚拟地址
===

我们都知道一个进程是与其他进程共享CPU和内存资源的。正因如此，操作系统需要有一套完善的内存管理机制才能防止进程之间内存泄漏的问题。

为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它**让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**。

虚拟内存的**重要意义**是它定义了一个连续的虚拟地址空间，使得程序的编写难度降低。并且，把内存扩展到硬盘空间只是使用虚拟内存的必然结果，虚拟内存空间会存在硬盘中，并且会被内存缓存（按需），有的操作系统还会在内存不够的情况下，将某一进程的内存全部放入硬盘空间中，并在切换到该进程时再从硬盘读取（这也是为什么Windows会经常假死的原因…）。

虚拟内存主要提供了如下三个重要的能力：

    它把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。

    它为每个进程提供了一个一致的地址空间，从而降低了程序员对内存管理的复杂性。

    它还保护了每个进程的地址空间不会被其他进程破坏。

CPU寻址
---

内存通常被组织为一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址（Physical Address PA），作为到数组的索引。CPU访问内存最简单直接的方法就是使用物理地址，这种寻址方式被称为物理寻址。

现代处理器使用的是一种称为虚拟寻址（Virtual Addressing）的寻址方式。使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。

虚拟寻址需要硬件与操作系统之间互相合作。CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。

页表
----

虚拟内存空间被组织为一个存放在硬盘上的M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，作为到数组的索引（这点其实与物理内存是一样的）。

操作系统通过将虚拟内存分割为大小固定的块来作为硬盘和内存之间的传输单位，这个块被称为虚拟页（Virtual Page, VP），每个虚拟页的大小为P=2^p字节。物理内存也会按照这种方法分割为物理页（Physical Page, PP），大小也为P字节。

CPU在获得虚拟地址之后，需要通过**MMU将虚拟地址翻译为物理地址**。而在翻译的过程中还需要借助**页表**，所谓页表就是一个存放在**物理内存中的数据结构**，它记录了**虚拟页与物理页的映射关系**。

页表是一个元素为页表条目（Page Table Entry, PTE）的集合，每个虚拟页在页表中一个固定偏移量的位置上都有一个PTE。下面是PTE仅含有一个有效位标记的页表结构，该有效位代表这个虚拟页是否被缓存在物理内存中。

页表是一个数据结构，它存储了虚拟地址到物理地址的映射关系。页表的每一项都是一个页表项（Page Table Entry, PTE），它包含了虚拟地址到物理地址的映射关系。页表项的结构如下：

    页表项的结构
    +-----------------+-----------------+-----------------+-----------------+
    | 有效位（Valid Bit） | 保留位（Reserved） | 物理页号（Physical Page Number） |
    +-----------------+-----------------+-----------------+-----------------+

    有效位（Valid Bit）：用于标识该页表项是否有效，如果该位为0，则表示该页表项无效，如果该位为1，则表示该页表项有效。
    保留位（Reserved）：用于保留，一般为0。
    物理页号（Physical Page Number）：用于存储该页表项对应的物理页号。

在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个PTE，使该PTE指向硬盘上这个新创建的虚拟页）。

**由于CPU每次进行地址翻译的时候都需要经过PTE**，所以如果想控制内存系统的访问，可以在PTE上添加一些额外的许可位（例如读写权限、内核权限等），这样只要有指令违反了这些许可条件，CPU就会触发一个一般保护故障，将控制权传递给内核中的异常处理程序。一般这种异常被称为“段错误（Segmentation Fault）”。

页命中
----

如上图所示，MMU根据虚拟地址在页表中寻址到了PTE 4，该PTE的有效位为1，代表该虚拟页已经被缓存在物理内存中了，最终MMU得到了PTE中的物理内存地址（指向PP 1）。

当CPU访问虚拟内存时，MMU会将虚拟地址转换为物理地址，这个过程称为地址翻译（Address Translation）。地址翻译的过程如下：

    1. 从虚拟地址中提取出虚拟页号（VPN）。
    2. 从页表中找到VPN对应的PTE。
    3. 如果PTE的有效位为0，则表示该虚拟页不在物理内存中，此时需要将该虚拟页调入物理内存中，然后再进行地址翻译。
    4. 如果PTE的有效位为1，则表示该虚拟页在物理内存中，此时需要从PTE中提取出物理页号（PPN）。
    5. 将虚拟页号的低位与物理页号拼接起来，得到物理地址。

缺页
----

如上图所示，MMU根据虚拟地址在页表中寻址到了PTE 2，该PTE的有效位为**0**，代表该虚拟页并没有被缓存在物理内存中。虚拟页没有被缓存在**物理内存中（缓存未命中）被称为缺页**。

当CPU遇见缺页时会触发一个缺页异常，缺页异常将控制权转向**操作系统内核**，然后调用内核中的缺页异常处理程序，该程序会选择一个**牺牲页**，如果牺牲页已被修改过，内核会先将它复制回硬盘（采用写回机制而不是直写也是为了尽量减少对硬盘的访问次数），然后再把该虚拟页覆盖到牺牲页的位置，并且更新PTE。

当缺页异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送给MMU。由于现在已经成功处理了缺页异常，所以最终结果是页命中，并得到物理地址。

这种在硬盘和内存之间传送页的行为称为**页面调度（paging）**：页从硬盘换入内存和从内存换出到硬盘。当缺页异常发生时，才将页面换入到内存的策略称为**按需页面调度**（demand paging），所有现代操作系统基本都使用的是按需页面调度的策略。

**虚拟内存跟CPU高速缓存（或其他使用缓存的技术）一样依赖于局部性原则**。虽然处理缺页消耗的性能很多（毕竟还是要从硬盘中读取），而且程序在运行过程中引用的不同虚拟页的总数可能会超出物理内存的大小，但是**局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合被称为工作集（working set）**。根据**空间局部性原则**（一个被访问过的内存地址以及其周边的内存地址都会有很大几率被再次访问）与**时间局部性原则**（一个被访问过的内存地址在之后会有很大几率被再次访问），只要将工作集缓存在物理内存中，接下来的地址翻译请求很大几率都在其中，从而减少了额外的硬盘流量。

如果一个程序没有良好的局部性，将会使工作集的大小不断膨胀，直至超过物理内存的大小，这时程序会产生一种叫做抖动（thrashing）的状态，页面会不断地换入换出，如此多次的读写硬盘开销，性能自然会十分“恐怖”。所以，想要编写出性能高效的程序，首先要保证程序的时间局部性与空间局部性。

多级页表
----

我们目前为止讨论的只是单页表，但在实际的环境中虚拟空间地址都是很大的（一个32位系统的地址空间有2^32 = 4GB，更别说64位系统了）。在这种情况下，使用一个单页表明显是效率低下的。

常用方法是使用层次结构的页表。假设我们的环境为一个32位的虚拟地址空间，它有如下形式：

    虚拟地址空间被分为4KB的页，每个PTE都是4字节。

    内存的前2K个页面分配给了代码和数据。

    之后的6K个页面还未被分配。

    再接下来的1023个页面也未分配，其后的1个页面分配给了用户栈。

下图是为该虚拟地址空间构造的二级页表层次结构（真实情况中多为四级或更多），一级页表（1024个PTE正好覆盖4GB的虚拟地址空间，同时每个PTE只有4字节，这样一级页表与二级页表的大小也正好与一个页面的大小一致都为4KB）的每个PTE负责映射虚拟地址空间中一个4MB的片（chunk），每一片都由1024个连续的页面组成。二级页表中的每个PTE负责映射一个4KB的虚拟内存页面。

这个结构看起来很像是一个B-Tree，这种层次结构有效的减缓了内存要求：

    如果一个一级页表的一个PTE是空的，那么相应的二级页表也不会存在。这代表一种巨大的潜在节约（对于一个普通的程序来说，虚拟地址空间的大部分都会是未分配的）。

    只有一级页表才总是需要缓存在内存中的，这样虚拟内存系统就可以在需要时创建、页面调入或调出二级页表（只有经常使用的二级页表才会被缓存在内存中），这就减少了内存的压力。

地址翻译的过程
----



虚拟内存的局限性

虚拟内存的局限性主要有两个：

    1. 虚拟内存的大小受限于物理内存的大小。
    2. 虚拟内存的访问速度受限于物理内存的访问速度。

https://sylvanassun.github.io/2017/10/29/2017-10-29-virtual_memory/#comments

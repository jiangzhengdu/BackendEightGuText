跨域
===

跨域是什么意思？
---

首先一个url是由：协议、域名、端口 三部分组成。（一般端口默认80）
如：https://blog.moonlet.cn:80

当一个请求url的协议、域名、端口三者之间的任意一个与当前页面url不同即为跨域。

跨域产生原因？
---

出于浏览器的同源策略限制。

**同源策略（Same Orgin Policy）是一种约定，它是浏览器核心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内  进行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）**
非同源会出现的限制

无法读取非同源网页的cookie、localstorage等
无法接触非同源网页的DOM和js对象
无法向非同源地址发送Ajax请求

解决办法
---

nginx反向代理解决跨域（前端常用）

**正向代理：**
a-->b访问不了，可以找个中间的服务器c, 先访问c再从c到b,类似曲线救国。
明确访问的目的地，但是用户不知道中间的代理服务器。（忽略中间服务器）
**反向代理：a--> c <--b**

a明确访问c代理服务器，但是不知道c的内容从哪里来，c反向从别的地方拿来数据。(忽略的是目标地址)

浏览器可以访问a,而服务器之间不存在跨域问题，浏览器先访问a的服务器c，让c服务器作为代理去访问b服务器,拿到之后再返回数据给a。

添加响应头解决跨域
---

浏览器先询问b,b允许a访问
access-control-allow-origin
access-control-max-age
PHP端修改header：
> header('Access-Control-Allow-Origin:*');//允许所有来源访问
> header('Access-Control-Allow-Method:POST,GET');//允许访问的方式

通过jsonp解决跨域（老方法）
---

实现原理：通常为了减轻web服务器的负载，我们把js、css、图片等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许。

html中有的标签天然支持跨域，比如<script src="http://www.baidu.com"></script>但是只支持get请求。

CORS解决跨域 (第三方模块)
---

它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。
浏览器端：
-----

目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。

服务端
-----

CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。

优势：

在服务端进行控制是否允许跨域，可自定义规则
支持各种请求方式

缺点：
会产生额外的请求

CSRF（Cross-site request forgery
----

CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！
也就是说你只要本地浏览器cookie中保存A网站的SessionID还没有失效，不管你从你的浏览器哪个网站发出的指向A网站请求，都会挟持到cookie，这个瞬间感觉WEB的隐式身份验证机制好傻逼。

其实CSRF远比这个例子要复杂,解决方式也很多，如下：

通过 referer、token 或者 验证码 来检测用户提交。
尽量不要在页面的链接中暴露用户隐私信息。
对于用户修改删除等操作最好都使用post 操作 。
避免全站通用的cookie，严格设置cookie的域。
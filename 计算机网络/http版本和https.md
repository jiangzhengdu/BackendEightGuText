超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息
===

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

　　为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，
为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

一、HTTP和HTTPS的基本概念

　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

二、HTTP与HTTPS有什么区别？

　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

版本变化
---

> **HTTP 0.9 -> HTTP 1.0 -> HTTP 1.1 -> HTTP 2**

HTTP 0.9
---

HTTP 0.9 是一个最古老的版本

只支持GET请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息
没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力
服务端相响应之后，立即关闭TCP连接

HTTP 1.0
---

随着 HTTP 1.0 的发布，这个版本:

请求方式新增了POST，DELETE，PUT，HEADER等方式
增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)
扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输
在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。

请求报文
请求报文主要分为三部分，**请求首行(request line), 请求头部(request header), 请求体(request body)**． 请求行与请求头部通过一个换行隔开，请求头部和请求体之间通过一个空行隔开．

请求行由**＂请求方法＂、＂URL＂和＂HTTP协议版本＂**3个字段组成，之字段间用空格分隔．
一个简单请求的头信息

``` HTTP
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

http协议中，有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段
通用首部字段
----

既可以出现在请求报文中，也可以出现在响应报文中，它提供了与报文相关的最基本的信息
    Cache-Control：用于控制缓存的行为
    Connection：控制不再转发给代理的首部字段、管理持久连接
    Date：提供日期和时间标志，说明报文是什么时间创建的
    MIME-Version：给出了发送端使用的MIME版本
    Trailer：如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文拖挂部分的首部集合
    Transfer-Encoding：报文主体的传输编码方式
    Update：给出升级为其他协议
    Via：显示了报文经过的中间节点(代理、网关)
    Pragma：报文指令
    Warning：错误通知

请求首部字段
----

只在请求报文中有意义的头部，用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力
    Accept：告诉服务器能够发送哪些媒体类型
    Accept-Charset：告诉服务器能够发送哪些字符集
    Accept-Encoding：告诉服务器能够发送哪些编码方式
    Accept-Language：告诉服务器能够发送哪些语言
    Authorization：Web 认证信息，以便对其自身进行认证的数据
    Client-IP：提供了运行客户端的机器的IP地址
    Expect：列出某请求所要求的服务器行为
    From：提供了客户端用户的E-mail地址
    Host：请求资源所在服务器，给出服务器的主机名和端口号
    If-Match：与实体标记（ETag）作比较，如果实体标记与文档当前的实体标记相匹配，就获取这份文档
    If-None-Match：比较实体标记（与 If-Match 相反），如果提供的实体标记与当前文档的实体标记不相符，就获取文档
    If-Modified-Sinec：比较资源的更新时间（Last-Modified），除非在某个指定的日期之后资源被修改过，否则就限制这个请求
    If-Unmodified-Since：除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
    Range：实体的字节范围请求,如果服务器支持范围请求，就请求资源的指定范围
    If-Range：资源未更新时发送实体 Byte 的范围请求,允许对文档的某个范围进行条件请求
    Referer：对请求中 URI 的原始获取方, 提供了包含当前请求URI的文档的URL
    UA-Color：提供了与客户端显示器的显示颜色有关的信息
    UA-CPU：给出了客户端CPU的类型或制造商
    UA-OS：给出了运行在客户端机器上的操作系统名称及版本
    UA-Pixels：HTTP 客户端程序的信息, 提供了客户端显示器的像素信息
    User-Agent：将发起请求的应用程序名称告知服务器
    TE：传输编码的优先级,告诉服务器可以使用那些扩展传输编码
    Cookie：客户端用它向服务器传送数据
    Cookie2：用来说明请求端支持的cookie版本
    Max-Forward：最大传输逐跳数,在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数
    Proxy-Authorization：代理服务器要求客户端的认证信息,这个首部在与代理进行认证时使用的
    Proxy-Connection：这个首部是在与代理建立连接时使用的

响应头

一个简单响应的头信息(v1.0)

``` HTTP
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
// 这是一个空行
...数据内容

```

服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。
Content-Type
在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以服务端返回时候必须带着这个字段。
一些常见的 Content-Type 可以参考 对照表。
这些 Content-Type 有一个总称叫做MIME type。
关于MIME type，这里想播插一个小插曲:

```在 chrome 浏览器中，当跨域请求回来的数据 MIME type 同跨域标签应有的 MIME type 不匹配时，浏览器会启动 CORB 保护数据不被泄漏。被保护的数据有: html、xml、json。(eg: script、img 标签所支持的 MIME type和他们都不一致)，所以服务端在返回资源的时候一定要对应返回正确的 Content-Type，以免浏览器屏蔽返回结果。
笔者遇到的问题是在 chrome v76 版本之后，跨域图片资源当请求回来的数据 Content-Type 不是 image/*，图片会被拦截，页面不展示图片。

```

响应首部字段
----

为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令
    Age：(从最初创建开始)响应持续时间
    Accept-Ranges：是否接受字节范围请求
    Public：服务器为其资源支持的请求方法列表
    Retry-After：如果资源不可用的话，在此日期或时间重试
    Server：服务器应用程序软件的名称和版本
    Title：对HTML文档来说，就是HTML文档的源端给出的标题
    Warning：比原因短语更详细一些的警告报文
    Vary：服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端
    Proxy-Authenticate：来自代理的对客户端的质询列表
    Set-Cookie：在客户端设置数据，以便服务器对客户端进行标识
    Set-Cookie2：与Set-Cookie类似
    WWW-Authenticate：来自服务器的对客户端的质询列表

实体首部字段
----

描述主体的长度和内容，或者资源自身的一些信息
    Allow：列出了可以对此实体执行的请求方法
    Location：告知客户端实体实际上位于何处，用于将接收端定向到资源的位置(URL)上去
    Content-Base：解析主体中的相对URL时使用的基础URL
    Content-Encoding：对主体执行的任意编码方式
    Content-Language：理解主体时最适宜使用的自然语言
    Content-Length：主体的长度
    Content-Location：资源实际所处的位置
    Content-MD5：主体的MD5校验和
    Content-Range：在整个资源中此实体表示的字节范围
    Content-Type：这个主体的对象类型
    ETag：与此实体相关的实体标记
    Expires：实体不再有效，要从原始的源端再次获取实体的日期和时间
    Last-Modified：这个实体最后一次被修改的日期和时间

特性
---

无状态：服务器不跟踪不记录请求过的状态
无连接：浏览器每次请求都需要建立tcp连接

无状态
对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录

无连接
无连接导致的性能缺陷有两种：

1. 无法复用连接 每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
队头阻塞
2. HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的

**HTTP 1.1***
---

HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。
特性

1. 长连接：新增Connection字段，可以设置keep-alive值保持连接不断开
2. 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回
3. 缓存处理：新增字段cache-control
4. 断点传输

长连接
----

HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据

管道化
-----

基于长连接的基础，我们先看没有管道化请求响应：

tcp没有断开，用的同一个通道
> 请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3

复制代码管道化的请求响应：
> 请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3

即使服务器先准备好响应2,也是按照请求顺序先返回响应1
虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题

缓存处理
----

当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。
通过设置字段cache-control来控制缓存。

断点传输
----

在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

**HTTP 2**
---

特性:

1. 二进制分帧
2. 多路复用： 在共享TCP链接的基础上同时发送请求和响应
3. 头部压缩
4. 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求

二进制分帧
----

HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率

**多路复用**
-----

在共享TCP链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来。

**头部压缩**
-----

由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源

我再用通俗的语言解释下，头部压缩需要在支持 HTTP/2 的浏览器和服务端之间：

维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合；
维护一份相同的动态字典（Dynamic Table），可以动态地添加内容；
支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）；

静态字典的作用有两个：1）对于完全匹配的头部键值对，例如 :method: GET，可以直接使用一个字符表示；2）对于头部名称可以匹配的键值对，例如 cookie: xxxxxxx，可以将名称使用一个字符表示。HTTP/2 中的静态字典如下（以下只截取了部分，完整表格在这里）：

HTTPS 和 HTTP

HTTPS 协议需要申请证书
HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443
HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
HTTPS 可以有效的防止运营商劫持

结尾
虽然在2015年，HTTP 2 就发布了，但是目前互联网的服务中，使用 HTTP 1.x 版本的服务不在少数，其中可能很大的一个原因是在当前的主流浏览器比如 chrome、Firefox 它们只支持基于 TLS 部署的 HTTP 2 协议，也就是说需要你的网站先升级为 HTTPS 才可以。然而 HTTPS 是需要申请证书的。
当然如果你的网站已经升级过 HTTPS 了，那么想升级 HTTP 2 就非常容易了。前端服务利器nginx能帮你做这所有，详见 Open Source NGINX 1.9.5 Released with HTTP/2 Support

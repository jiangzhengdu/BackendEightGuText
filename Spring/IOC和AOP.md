Spring的 IOC和AOP机制
===

（1）我们是在使用 Spring框架的过程中，其实就是为了使用 IOC（控制反转）、依赖注入（DI与IOC一样）和AOP（面向切面编程），这两个也是 Spring 的灵魂。

（2）主要用到的设计模式有工厂模式和代理模式

IOC就是典型的工厂模式，AOP就是典型的代理模式的体现。

      代理模式是常用的Java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。

（3）Spring的 IoC容器是 Spring的核心，Spring AOP是 Spring框架的重要组成部分。

IoC：控制反转:

      在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在 Spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由 Spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。

      面向切面编程（AOP）是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。OOP将应用程序分解成各个层次的对象，而AOP将程序分解成多个切面（切面就是要添加的非核心功能）。Spring AOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。在 Spring中，未来使 IoC方便地使用健壮、灵活的企业服务，需要利用 Spring AOP实现为IoC和企业服务之间建立联系。

      IOC控制反转也叫依赖注入。利用了工厂模式将对象交给容器管理，你只需要在 Spring 总配置文件中配置相应的bean，以及设置相关的属性，让 Spring容器来生成类的实例对象以及管理对象。在 Spring容器启动的时候，Spring会把你在配置文件中配置的 bean都初始化好（这里就会涉及到复杂的 bean 创建的生命周期），然后在你需要调用的时候，就把它已经初始化好的那些 bean 分配给你需要调用这些 bean的类（假设这个类名是A），分配的方法就是调用 A 的 setter方法来注入，而不需要你在A里面 new 这些 bean了。

问：控制反转和依赖注入式同一个概念吗？

控制反转和依赖注入是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。

      依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；

      而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。

问：bean 和 Java对象的区别：

① bean 是经历过完整的 bean 生命周期生成的放在单例池（singletonObjects)中的对象（大部分bean 是这样的）是有 Spring 容器创建出来的；

② bean 是一个Java对象，而Java对象并不一定是 bean（这一点并没有官方做支撑，个人理解）。

③ bean 创建好之后它的属性就是赋完值的，也就是 bean 是属性不是默认值的一个对象，而 new 出来的对象的属性是默认值。

AOP：面向切面编程（Aspect-Oriented Programming）:

      AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能、事务管理、权限认证、异常处理等等吧。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。

      实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。
简单点解释，比方说你想在你的 service 层所有类中都加上一个打印"你好"的功能,这时就可以用 AOP 思想来做。你先写个类及其方法，方法实现打印"你好"，然后将这个类都注入到每一个需要实现打印的类中即可实现。

依赖注入的方式有几种，各是什么?
---

（1）构造器注入

      将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。

优点：对象初始化完成后便可获得可使用的对象。

缺点：
      ① 当需要注入的对象很多时，构造器参数列表将会很长；
      ② 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。

（2）setter方法注入

      IoC Service Provider 通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。

优点：灵活。可以选择性地注入需要的对象。

缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。

（3）接口注入

      依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。

优点：接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。

缺点：侵入性太强，不建议使用。

PS：什么是侵入行？
      如果类A要使用别人提供的一个功能，若为了使用这功能，需要在自己的类中增加额外的代码，这就是侵入性
